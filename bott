# bots/personal_bot/bot.py
from openai import OpenAI
import os
from .auto_edit import replace_programmer_block
from .memory_handler import load_memory, save_memory

# Загружаем память при старте
memory = load_memory()

def handle_request(user_text, role=None):
    """
    role: "user", "programmer" или None
    """
    OPENAI_KEY = os.getenv("OPENAI_API_KEY")
    if not OPENAI_KEY:
        return "Ошибка: OPENAI_API_KEY не задан!"
    client = OpenAI(api_key=OPENAI_KEY)

    # Команда для обновления правил программиста
    if "обнови правила программиста" in user_text.lower():
        # Пример: пользователь пишет "обнови правила программиста: ..."
        new_msg = user_text.split(":", 1)[-1].strip()
        memory["programmer_system_msg"] = new_msg
        save_memory(memory)
        return "Правила программиста обновлены ✅"

    # Команда для автоматической замены блока programmer
    if "замени блок programmer на красиво отформатированный" in user_text.lower():
        file_path = os.path.join(os.path.dirname(__file__), "bot.py")
        return replace_programmer_block(file_path)

    # Автоопределение роли
    if role is None:
        code_triggers = ["функция", "код", "python", "пример", "скрипт", "программа"]
        if any(word.lower() in user_text.lower() for word in code_triggers):
            role = "programmer"
        else:
            role = "user"

    # Используем системное сообщение из памяти
    system_msg = memory["programmer_system_msg"] if role == "programmer" else memory["user_system_msg"]

    resp = client.chat.completions.create(
        model="gpt-4o-mini",
        messages=[
            {"role": "system", "content": system_msg},
            {"role": "user", "content": user_text}
        ],
        temperature=0.7
    )

    return resp.choices[0].message.content
